#include <stdio.h>
#include <stdlib.h>
/*
// битовые операторы:
// & "и" например 5 & 6  == 4;
// | или если хоть что то истина то ответ истина

// ^
// исключающее или все одинаковые значения дают ноль все разные значения дают 1

// ~
// не, другими словами инверсия

// >>
// арифметический битовый сдвиг вправо 8 >> 1 в числе 8 сдвиг на 1 в право
// то же самое что разделить число на 2
// но при этом округление происходит в меньшую стророну например 9 >> 1 == 4
// свободный бит справа зануляется

// <<
// арифметический битовый сдвиг влево
// то же самое что умножить число на 2 в степени n
// свободный бит слева зануляется

//проверка бита, принимает число с битами которого нужно работать
// и номер бита относительно младших разрядов
 все правые биты заполняются нолями

int s21_get_bit(unsigned int number, int index) {
  // возвр результат сравнения единицы сдвинутой на искомую позицию индекс
  // сравниваем с числом и если там тоже 1 то вернем 1
  // или если там ноль то ноль не ноль лож вернем ноль
  return (number & (1 << index)) != 0;
}

// установка бита в 1 принимает число с битами которого нужно работать
// и номер бита относительно младших разрядов
int s21_set_bit(unsigned int *number, int index) {
  *number = *number | (1 << index);
  return 0;
}

// установка всех битов в 1 работает с динамикой
void s21_set_all_bits(s21_decimal *value) {
  for (int i = 3; i > 0; --i) {
    for (int j = 0; j < 32; ++j) {
      value->bits[i] = value->bits[i] | (1 << j);
    }
  }
}

// инверсия бита принимает число с битами которого нужно работать
// и номер бита относительно младших разрядов
// все правые биты заполняются нолями
void s21_inverse_bit(unsigned int *number, int index) { *number = *number ^ (1 << index); }

// установка бита в 0 принимает число с битами которого нужно работать
// и номер бита относительно младших разрядов
void s21_reset_bit(unsigned int *number, int index) {
  // сдвинули единицу на нужную позицию и затем инвертировали все значения
  *number = *number & ~(1 << index);

}
*/

// 79228162514264337593543950335
// int -2147483648 2147483648
// uint 4294967295
// int -2147483647 2147483647
/*
                             
0b00000000000000000000000000000010;
0b01111111111111111111111111111111;
// uint 4294967295U
0b11111111111111111111111111111111;
// 79228162514264337593543950335
// 79228162514264337593543950335
// dec:
0b111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
0b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
// 4 int    //ot 16 do 24 bit                  
0b (1) 000000 (00000010) 00000000000000000;
0b0000000000000000000000000000010;
//  manti
// Сложение 
0b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
0b 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000
*/

int s21_get_bit(unsigned int number, int index) {
  // возвр результат сравнения единицы сдвинутой на искомую позицию индекс
  // сравниваем с числом и если там тоже 1 то вернем 1
  // или если там ноль то ноль не ноль лож вернем ноль
  return (number & (1 << index)) != 0;
}

// установка бита в 1 принимает число с битами которого нужно работать
// и номер бита относительно младших разрядов
int s21_set_bit(unsigned int *number, int index) {
  *number = *number | (1 << index);
  return 0;
}

int main() {
    int value_1 = 10;
    //big decimal struct (структура на 8 интах)
    //get bit to big decimal struct
    //set bit to big decimal struct
    //check SCALE (int) ! max 28 (узнать степень)

    //для сложения    
    //проверка знака
    //compare SCALE (сравнение степеней)
    //check diff in SCALE (проверка разницы между степенями)
    //multiply 10 x N times (умножение на 10 * разницу раз)
    //divide by 10 (функция деления на 10 пока степень до 28вкл)
    //check overflow (проверка на переполнение при делении на 10 в пределах допустимой степени)

    for(int i = 31; i >= 0; --i) {
        printf("%d", s21_get_bit(value_1, i));
    }

}